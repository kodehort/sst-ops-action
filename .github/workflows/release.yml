name: Release Automation

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      release_type:
        description: "Type of release (auto, patch, minor, major)"
        required: true
        default: "auto"
        type: choice
        options:
          - auto
          - patch
          - minor
          - major
      prerelease:
        description: "Mark as prerelease"
        required: false
        default: false
        type: boolean

concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: false

permissions: write-all
# permissions:
#   contents: write
#   packages: write
#   pull-requests: write
#   issues: write
#   actions: read
#   id-token: write

jobs:
  determine-release:
    name: Determine Release Type
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    outputs:
      should-release: ${{ steps.release-check.outputs.should-release }}
      release-type: ${{ steps.release-check.outputs.release-type }}
      new-version: ${{ steps.release-check.outputs.new-version }}
      current-version: ${{ steps.release-check.outputs.current-version }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install semantic-release dependencies
        run: |
          npm install -g semantic-release
          npm install -g @semantic-release/changelog
          npm install -g @semantic-release/git
          npm install -g @semantic-release/github
          npm install -g @semantic-release/exec
          npm install -g conventional-changelog-conventionalcommits

      - name: Determine Release Type
        id: release-check
        run: |
          # Get current version from package.json
          CURRENT_VERSION=$(node -p "require('./package.json').version")
          echo "current-version=$CURRENT_VERSION" >> $GITHUB_OUTPUT

          # Debug: Show git state
          echo "=== Git Debug Information ==="
          echo "Current HEAD: $(git rev-parse HEAD)"
          echo "Available tags:"
          git tag -l | sort -V | tail -10
          echo "Git describe output:"
          git describe --tags --abbrev=0 2>/dev/null || echo "No tags found via git describe"
          echo "Recent commits:"
          git log --oneline -5
          echo "=============================="

          # Check if there are commits since last release
          LAST_TAG=$(git tag --sort=-version:refname | head -1)
          echo "Last tag found: '$LAST_TAG'"

          if [ -z "$LAST_TAG" ]; then
            COMMITS_SINCE_LAST=$(git rev-list --count HEAD)
            echo "No last tag found, counting all commits from HEAD"
          else
            COMMITS_SINCE_LAST=$(git rev-list --count ${LAST_TAG}..HEAD)
            echo "Counting commits from $LAST_TAG to HEAD"
          fi

          echo "Commits since last release: $COMMITS_SINCE_LAST"

          # Determine if we should release
          if [ "$COMMITS_SINCE_LAST" -eq 0 ] && [ "${{ github.event_name }}" != "workflow_dispatch" ]; then
            echo "should-release=false" >> $GITHUB_OUTPUT
            echo "No new commits since last release"
            exit 0
          fi

          # Analyze commit messages for semantic versioning
          if [ "${{ github.event.inputs.release_type }}" != "auto" ] && [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            RELEASE_TYPE="${{ github.event.inputs.release_type }}"
          else
            # Auto-determine release type based on conventional commits
            if [ -z "$LAST_TAG" ]; then
              COMMITS_TO_CHECK=$(git log --pretty=format:"%s" HEAD)
            else
              COMMITS_TO_CHECK=$(git log --pretty=format:"%s" ${LAST_TAG}..HEAD)
            fi

            echo "Analyzing commits:"
            echo "$COMMITS_TO_CHECK"

            # Check for breaking changes (major version)
            if echo "$COMMITS_TO_CHECK" | grep -qE "^[a-zA-Z]+(\(.+\))?!:" || echo "$COMMITS_TO_CHECK" | grep -qE "BREAKING CHANGE"; then
              RELEASE_TYPE="major"
            # Check for features (minor version)
            elif echo "$COMMITS_TO_CHECK" | grep -qE "^feat(\(.+\))?:"; then
              RELEASE_TYPE="minor"
            # Check for fixes, docs, etc (patch version)
            elif echo "$COMMITS_TO_CHECK" | grep -qE "^(fix|docs|style|refactor|perf|test|chore)(\(.+\))?:"; then
              RELEASE_TYPE="patch"
            # If no conventional commits found, default to patch
            else
              RELEASE_TYPE="patch"
            fi
          fi

          echo "should-release=true" >> $GITHUB_OUTPUT
          echo "release-type=$RELEASE_TYPE" >> $GITHUB_OUTPUT

          # Calculate new version
          IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
          MAJOR=${VERSION_PARTS[0]}
          MINOR=${VERSION_PARTS[1]}
          PATCH=${VERSION_PARTS[2]}

          case $RELEASE_TYPE in
            major)
              NEW_VERSION="$((MAJOR + 1)).0.0"
              ;;
            minor)
              NEW_VERSION="${MAJOR}.$((MINOR + 1)).0"
              ;;
            patch)
              NEW_VERSION="${MAJOR}.${MINOR}.$((PATCH + 1))"
              ;;
          esac

          echo "new-version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "Determined release type: $RELEASE_TYPE ($CURRENT_VERSION ‚Üí $NEW_VERSION)"

  build-test-validate:
    name: Build, Test & Validate
    runs-on: ubuntu-latest
    needs: determine-release
    if: needs.determine-release.outputs.should-release == 'true'

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Environment
        uses: ./.github/actions/setup-node-env
        with:
          bun-version: "1.2.19"
          cache-key-suffix: -release

      - name: Run Quality Gates
        run: |
          echo "üîç Running comprehensive quality checks..."
          bun run typecheck
          bun run lint
          bun run test
          echo "‚úÖ All quality gates passed"

      - name: Build Production Bundle
        run: |
          echo "üî® Building production bundle..."
          bun run build
          echo "‚úÖ Production build completed"

      - name: Verify Bundle
        run: |
          echo "üß™ Verifying production bundle..."

          # Check bundle exists
          if [ ! -f "dist/index.js" ]; then
            echo "‚ùå Bundle file not found"
            exit 1
          fi

          # Check bundle size
          BUNDLE_SIZE=$(stat -c%s dist/index.js 2>/dev/null || stat -f%z dist/index.js)
          BUNDLE_SIZE_MB=$(echo "scale=2; $BUNDLE_SIZE / 1024 / 1024" | bc)
          echo "Bundle size: ${BUNDLE_SIZE_MB}MB"

          if (( $(echo "$BUNDLE_SIZE_MB > 10" | bc -l) )); then
            echo "‚ùå Bundle size exceeds 10MB limit!"
            exit 1
          fi

          echo "‚úÖ Bundle verification passed"

      - name: Upload Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-build-${{ github.sha }}
          path: |
            dist/
            package.json
            action.yml
          retention-days: 30

      - name: Test Action Usage
        id: test-action
        continue-on-error: true
        uses: ./
        with:
          operation: diff
          stage: test-release
          token: ${{ secrets.GITHUB_TOKEN }}
          comment-mode: never
          fail-on-error: false

      - name: Validate Distribution Files
        run: |
          echo "üîç Validating distribution files..."

          # Check that files exist
          if [ ! -f "dist/index.js" ]; then
            echo "‚ùå dist/index.js not found"
            exit 1
          fi

          if [ ! -f "action.yml" ]; then
            echo "‚ùå action.yml not found"
            exit 1
          fi

          # Verify action.yml points to correct main file
          if ! grep -q "main.*dist/index.js" action.yml; then
            echo "‚ùå action.yml does not reference dist/index.js"
            exit 1
          fi

          # Check for build manifest
          if [ ! -f "dist/build-manifest.json" ]; then
            echo "‚ö†Ô∏è build-manifest.json missing, this may affect release notes"
          fi

          echo "‚úÖ Distribution validation passed"

      - name: Validate Action Functionality
        run: |
          echo "üîç Validating action functionality..."

          # Check if the action test step succeeded
          if [ "${{ steps.test-action.outcome }}" = "failure" ]; then
            echo "‚ùå Action functionality test failed"
            echo "Test output:"
            echo "${{ steps.test-action.outputs }}"
            exit 1
          fi

          echo "‚úÖ Action functionality validation passed"

  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [determine-release, build-test-validate]
    if: needs.determine-release.outputs.should-release == 'true'

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Git Config
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Setup Environment
        uses: ./.github/actions/setup-node-env
        with:
          bun-version: "1.2.19"
          cache-key-suffix: -release

      - name: Download Build Artifacts
        uses: actions/download-artifact@v4
        with:
          name: release-build-${{ github.sha }}
          path: ./

      - name: Verify Build Artifacts
        run: |
          echo "üîç Verifying downloaded build artifacts..."

          # Check if dist files exist in artifacts
          if [ ! -f "dist/index.js" ]; then
            echo "‚ö†Ô∏è dist/index.js not found in artifacts, rebuilding..."
            bun run build
          else
            echo "‚úÖ dist/index.js found in artifacts"
          fi

          if [ ! -f "dist/build-manifest.json" ]; then
            echo "‚ö†Ô∏è build-manifest.json missing, this may affect changelog generation"
          else
            echo "‚úÖ build-manifest.json found"
          fi

          # Final verification that required files exist
          if [ ! -f "dist/index.js" ]; then
            echo "‚ùå Critical: dist/index.js still missing after rebuild attempt"
            exit 1
          fi

          echo "‚úÖ Build artifacts verified"

      - name: Update Version
        run: |
          NEW_VERSION="${{ needs.determine-release.outputs.new-version }}"
          echo "Updating version to $NEW_VERSION"

          # Update package.json version
          npm version $NEW_VERSION --no-git-tag-version

          echo "‚úÖ Version updated to $NEW_VERSION"

      - name: Generate Changelog
        id: changelog
        run: |
          NEW_VERSION="${{ needs.determine-release.outputs.new-version }}"
          CURRENT_VERSION="${{ needs.determine-release.outputs.current-version }}"

          # Get the last tag, or use first commit if no tags exist
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || git rev-list --max-parents=0 HEAD)

          echo "Generating changelog from $LAST_TAG to HEAD"

          # Generate changelog content
          cat > RELEASE_NOTES.md << EOF
          # Release v${NEW_VERSION}

          **Release Date:** $(date -u +"%Y-%m-%d")
          **Previous Version:** v${CURRENT_VERSION}

          ## üöÄ What's New

          EOF

          # Parse commits for changelog
          COMMITS=$(git log --pretty=format:"%h %s" ${LAST_TAG}..HEAD 2>/dev/null || git log --pretty=format:"%h %s" HEAD)

          # Categorize commits
          echo "" >> RELEASE_NOTES.md

          # Features
          FEATURES=$(echo "$COMMITS" | grep -E "^[a-f0-9]+ feat(\(.+\))?: " || true)
          if [ -n "$FEATURES" ]; then
            echo "### ‚ú® Features" >> RELEASE_NOTES.md
            echo "" >> RELEASE_NOTES.md
            echo "$FEATURES" | while IFS= read -r line; do
              if [ -n "$line" ]; then
                HASH=$(echo "$line" | cut -d' ' -f1)
                MSG=$(echo "$line" | cut -d' ' -f2-)
                echo "- $MSG (\`$HASH\`)" >> RELEASE_NOTES.md
              fi
            done
            echo "" >> RELEASE_NOTES.md
          fi

          # Bug fixes
          FIXES=$(echo "$COMMITS" | grep -E "^[a-f0-9]+ fix(\(.+\))?: " || true)
          if [ -n "$FIXES" ]; then
            echo "### üêõ Bug Fixes" >> RELEASE_NOTES.md
            echo "" >> RELEASE_NOTES.md
            echo "$FIXES" | while IFS= read -r line; do
              if [ -n "$line" ]; then
                HASH=$(echo "$line" | cut -d' ' -f1)
                MSG=$(echo "$line" | cut -d' ' -f2-)
                echo "- $MSG (\`$HASH\`)" >> RELEASE_NOTES.md
              fi
            done
            echo "" >> RELEASE_NOTES.md
          fi

          # Other improvements
          OTHERS=$(echo "$COMMITS" | grep -E "^[a-f0-9]+ (docs|style|refactor|perf|test|chore)(\(.+\))?: " || true)
          if [ -n "$OTHERS" ]; then
            echo "### üîß Improvements & Maintenance" >> RELEASE_NOTES.md
            echo "" >> RELEASE_NOTES.md
            echo "$OTHERS" | while IFS= read -r line; do
              if [ -n "$line" ]; then
                HASH=$(echo "$line" | cut -d' ' -f1)
                MSG=$(echo "$line" | cut -d' ' -f2-)
                echo "- $MSG (\`$HASH\`)" >> RELEASE_NOTES.md
              fi
            done
            echo "" >> RELEASE_NOTES.md
          fi

          # Add bundle information
          if [ -f "dist/build-manifest.json" ]; then
            BUNDLE_SIZE_MB=$(jq -r '.bundleSizeMB' dist/build-manifest.json)
            BUNDLE_SIZE=$(jq -r '.bundleSize' dist/build-manifest.json)
            BUNDLE_INTEGRITY=$(jq -r '.integrity' dist/build-manifest.json)

            cat >> RELEASE_NOTES.md << EOF
          ## üì¶ Bundle Information

          - **Bundle Size:** ${BUNDLE_SIZE_MB}MB (${BUNDLE_SIZE} bytes)
          - **Integrity Hash:** \`${BUNDLE_INTEGRITY:0:16}...\`
          - **Format:** ES Modules for GitHub Actions
          - **Target:** Node.js 20+
          - **Source Maps:** Included for debugging
          - **Distribution:** Files included as release assets

          EOF
          fi

          # Add usage example
          cat >> RELEASE_NOTES.md << EOF
          ## üöÄ Usage

          \`\`\`yaml
          - name: SST Operations
            uses: ${{ github.repository }}@v${NEW_VERSION}
            with:
              operation: deploy  # deploy, diff, or remove
              stage: production
              token: \${{ secrets.GITHUB_TOKEN }}
          \`\`\`

          ## üîó Links

          - [Full Changelog](https://github.com/${{ github.repository }}/compare/v${CURRENT_VERSION}...v${NEW_VERSION})
          - [Documentation](https://github.com/${{ github.repository }}/blob/v${NEW_VERSION}/README.md)
          - [Action Marketplace](https://github.com/marketplace/actions/sst-operations)

          ---

          **Full Changelog**: https://github.com/${{ github.repository }}/compare/v${CURRENT_VERSION}...v${NEW_VERSION}
          EOF

          echo "‚úÖ Release notes generated"

      - name: Update CHANGELOG.md
        run: |
          NEW_VERSION="${{ needs.determine-release.outputs.new-version }}"

          # Create or update CHANGELOG.md
          if [ ! -f "CHANGELOG.md" ]; then
            cat > CHANGELOG.md << EOF
          # Changelog

          All notable changes to this project will be documented in this file.

          The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
          and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

          EOF
          fi

          # Prepend new version to CHANGELOG.md
          cat RELEASE_NOTES.md > temp_changelog.md
          echo "" >> temp_changelog.md
          echo "---" >> temp_changelog.md
          echo "" >> temp_changelog.md
          cat CHANGELOG.md >> temp_changelog.md
          mv temp_changelog.md CHANGELOG.md

          echo "‚úÖ CHANGELOG.md updated"

      - name: Commit Version Updates
        run: |
          NEW_VERSION="${{ needs.determine-release.outputs.new-version }}"

          # Add all changed files including distribution files for GitHub Actions compatibility
          git add package.json CHANGELOG.md dist/

          # Commit changes
          git commit -m "chore(release): v${NEW_VERSION} [skip ci]

          - Update package.json version to ${NEW_VERSION}
          - Update CHANGELOG.md with release notes
          - Add distribution files for GitHub Actions compatibility"

          # Create annotated tag
          git tag -a "v${NEW_VERSION}" -m "Release v${NEW_VERSION}

          $(cat RELEASE_NOTES.md)"

          # Push changes and tag
          git push origin main
          git push origin "v${NEW_VERSION}"

          echo "‚úÖ Version committed and tagged"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - uses: actions/create-github-app-token@v1
        id: app-token
        with:
          app-id: ${{ secrets.GH_CI_APP_ID }}
          private-key: ${{ secrets.GH_CI_APP_PRIVATE_KEY }}

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          token: ${{ steps.app-token.outputs.token }}
          tag_name: v${{ needs.determine-release.outputs.new-version }}
          name: "SST Ops Action v${{ needs.determine-release.outputs.new-version }}"
          body_path: ./RELEASE_NOTES.md
          files: |
            dist/index.js
            dist/index.js.map
            dist/build-manifest.json
            action.yml
            package.json
          draft: false
          prerelease: ${{ github.event.inputs.prerelease == 'true' }}

      - name: Update Major Version Tag
        run: |
          NEW_VERSION="${{ needs.determine-release.outputs.new-version }}"
          MAJOR_VERSION="v$(echo $NEW_VERSION | cut -d. -f1)"

          echo "Updating major version tag: $MAJOR_VERSION"

          # Create or update major version tag (e.g., v1, v2)
          git tag -f "$MAJOR_VERSION" "v${NEW_VERSION}"
          git push -f origin "$MAJOR_VERSION"

          echo "‚úÖ Major version tag updated: $MAJOR_VERSION"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  notify-success:
    name: Notify Release Success
    runs-on: ubuntu-latest
    needs: [determine-release, create-release]
    if: needs.determine-release.outputs.should-release == 'true' && success()

    steps:
      - name: Notify Success
        run: |
          NEW_VERSION="${{ needs.determine-release.outputs.new-version }}"
          RELEASE_TYPE="${{ needs.determine-release.outputs.release-type }}"

          echo "üéâ Release v$NEW_VERSION completed successfully!"
          echo "üì¶ Release type: $RELEASE_TYPE"
          echo "üîó Release URL: https://github.com/${{ github.repository }}/releases/tag/v$NEW_VERSION"
          echo "üìã Changelog: https://github.com/${{ github.repository }}/blob/main/CHANGELOG.md"
